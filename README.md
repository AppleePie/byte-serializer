## Байтовый сериализатор

### Принцип работы

Работает по достаточно простой структуре:

- В начало добавляется проверочный символ (стандартно - `\0`)

- Примитивные типы серилизует в байты как есть. 
  
`3213 -> 141.12.0.0`

- Строки сериализует по кодам их символов в UTF8.

`si vic pacem para bellum -> 115.105.32.118.105.99.32.112.97.99.101.109.32.112.97.114.97.32.98.101.108.108.117.10`

- Массивы сериализуются по схеме \[Количество элементов (int)] \[Тип(строка)] \[Рекурсивно сериализованные элементы]
`[1, 2, 3, 4, 6] -> 0.5.0.0.0.5.0.0.0.0.1.0.0.0.5.0.0.0.0.2.0.0.0.5.0.0.0.0.3.0.0.0.5.0.0.0.0.4.0.0.0.5.0.0.0.0.5.0.0.0`
  
- Ссылочные типы серилизуются рекурсивно по схеме \[Длина байтового потока (int)] \[Длина поля класса (int)] \[Название поля класса (string)] \[Длина потока сериализованного значения поля] \[Сериализованное значение поля]

Ограничение: поля ссылочных типов не должны содержать идентификатор `readonly`.
  
```c#
var packet = new Packet
{
    Integer = int.MaxValue,
    Double = double.NegativeInfinity,
    String = "abcde",
    NestingPacket = new Packet {Integer = 123, Double = 1243, String = "alpha"},
    Birthday = DateTime.Now,
    Numbers = new []{123, 213, 213}
};

```
```
0.7.0.0.0.73.110.116.101.103.101.114.5.0.0.0.0.255.255.255.127.6.0.0.0.68.111.117.98.108.101.9.0.0.0.0.0.0.0.0.0.0.240.255.6.0.0.0.83.116.114.105.110.103.6.0.0.0.0.97.98.99.100.101.13.0.0.0.78.101.115.116.105.110.103.80.97.99.107
.101.116.154.0.0.0.0.7.0.0.0.73.110.116.101.103.101.114.5.0.0.0.0.123.0.0.0.6.0.0.0.68.111.117.98.108.101.9.0.0.0.0.0.0.0.0.0.108.147.64.6.0.0.0.83.116.114.105.110.103.6.0.0.0.0.97.108.112.104.97.13.0.0.0.78.101.115.116.105.110.1
03.80.97.99.107.101.116.1.0.0.0.0.8.0.0.0.66.105.114.116.104.100.97.121.20.0.0.0.0.48.49.47.48.49.47.48.48.48.49.32.48.48.58.48.48.58.48.48.7.0.0.0.78.117.109.98.101.114.115.1.0.0.0.0.7.0.0.0.80.97.99.107.101.116.115.1.0.0.0.0.8.
0.0.0.66.105.114.116.104.100.97.121.20.0.0.0.0.48.55.47.48.51.47.50.48.50.49.32.49.51.58.52.52.58.53.52.7.0.0.0.78.117.109.98.101.114.115.32.0.0.0.0.3.0.0.0.5.0.0.0.0.123.0.0.0.5.0.0.0.0.213.0.0.0.5.0.0.0.0.213.0.0.0.7.0.0.0.80.9
7.99.107.101.116.115.163.0.0.0.0.1.0.0.0.154.0.0.0.0.7.0.0.0.73.110.116.101.103.101.114.5.0.0.0.0.123.0.0.0.6.0.0.0.68.111.117.98.108.101.9.0.0.0.0.0.0.0.0.0.108.147.64.6.0.0.0.83.116.114.105.110.103.6.0.0.0.0.97.108.112.104.97.1
3.0.0.0.78.101.115.116.105.110.103.80.97.99.107.101.116.1.0.0.0.0.8.0.0.0.66.105.114.116.104.100.97.121.20.0.0.0.0.48.49.47.48.49.47.48.48.48.49.32.48.48.58.48.48.58.48.48.7.0.0.0.78.117.109.98.101.114.115.1.0.0.0.0.7.0.0.0.80.97
.99.107.101.116.115.1.0.0.0.0

```

### Дополнительные / альтернативные способы сериализации типов

Можно переопределить сериализацию какого-то типа / добавить собственную сериализацию определенного типа.

Для этого необходимо:

- Реализовать интерфейс ISerializer у класса вашего сериализатора

- У экземпляра ObjectSerializer вызвать метод AddCustom, в качестве аргумента передав экземпляр вашего сериализатора

Тогда при сериализации / десериализации конкретного типа будет вызван соответствующий метод у класса вашего сериализатора.